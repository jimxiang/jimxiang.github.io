<!doctype html>



  


<html class="theme-next mist use-motion" lang="en">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.0" />






<meta name="description">
<meta property="og:type" content="website">
<meta property="og:title" content="Ji Xiang's blog">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Ji Xiang's blog">
<meta property="og:description">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Ji Xiang's blog">
<meta name="twitter:description">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/"/>





  <title> Ji Xiang's blog </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="en">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-left 
  
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">Ji Xiang's blog</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
    
      <p class="site-subtitle">Walk step by step and learn everyday</p>
    
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archives
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            Tags
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/02/04/动态规划/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="Ji Xiang">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="http://o7bp9e1ec.bkt.clouddn.com/1485173143816">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="Ji Xiang's blog">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="Ji Xiang's blog" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/02/04/动态规划/" itemprop="url">
                  动态规划
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-02-04T16:51:38+08:00">
                2017-02-04
              </time>
            

            

            
          </span>

          

          
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="动态规划算法的思路以及实现">动态规划算法的思路以及实现</h2><h2 id="介绍">介绍</h2><blockquote>
<p>动态规划(DP)是算法设计思想当中最难也是最有趣的部分了，动态规划适用于有重叠子问题和最优子结构性质的问题，是一种在数学、计算机科学和经济学中经常使用的，通过把原问题分解为相对简单的子问题的方式求解复杂问题的方法。使用动态规划方法解题有较高的时间效率，关键在于它减少了很多不必要的计算和重复计算的部分。</p>
</blockquote>
<p>它的思想就是把一个大的问题进行拆分，细分成一个个小的子问题，且能够从这些小的子问题的解当中推导出原问题的解。同时还需要满足以下两个重要的性质才能进行动态规划：</p>
<ul>
<li>最优子结构性：既所拆分的子问题的解是最优解。</li>
<li>子问题重叠性质：既在求解的过程当中，每次产生的子问题并不总是新问题，有些子问题会被重复计算多次。动态规划算法是利用了这种子问题的重叠性质，对每一个子问题只计算一次，然后将其计算结果保存在一个表格中，当再次需要计算已经计算过的子问题时，只是在表格中简单地查看一下结果，从而获得较高的解题效率。</li>
</ul>
<h2 id="示例">示例</h2><blockquote>
<p>首先引用一道动态规划的经典问题<strong>最长不下降子序列</strong><br>它的定义是：设有由n个不相同的整数组成的数列 b[n]，若有下标 i1 &lt; i2 &lt; … &lt; iL 且 b[i1] &lt; b[i2] &lt; … &lt; b[iL]<br>则称存在一个长度为 L 的不下降序列。</p>
</blockquote>
<h3 id="例如">例如</h3><blockquote>
<p>13, 7, 9, 16, 38, 24, 37, 18, 44, 19, 21, 22, 63, 15</p>
</blockquote>
<p>那么就有 13 &lt; 16 &lt; 38 &lt; 44 &lt; 63 长度为5的不下降子序列。<br>但是经过观察实际上还有 7 &lt; 9 &lt; 16 &lt; 18 &lt; 19 &lt; 21 &lt; 22 &lt; 63 长度为8的不下降子序列，那么是否还有更长的不下降子序列呢？请找出最长的不下降子序列。</p>
<h3 id="输入格式">输入格式</h3><blockquote>
<p>第一行为 n，表示 n 个数(n &lt;= 100000)，第二行为 n 个数的数值(数字之间用空格隔开且最后一个数字末尾不能留有空格)。</p>
</blockquote>
<h3 id="输出格式">输出格式</h3><blockquote>
<p>一个整数，表示最长不下降序列的长度。</p>
</blockquote>
<h3 id="输入例子">输入例子</h3><blockquote>
<p>4<br>1 3 1 2</p>
</blockquote>
<h3 id="输出例子">输出例子</h3><blockquote>
<p>2</p>
</blockquote>
<h3 id="思路">思路</h3><blockquote>
<p>假如要求得某一段的最优，就要想更小段的最优怎么求，再看看由最小段的最优能否扩大推广到最大段的最优。所以该问题存在最优子结构，而从小段的最优子结构到更大的最优子结构，所有子结构的求解问题是相同的，即满足动态规划的性质。</p>
</blockquote>
<p>假设这么一个表：   </p>
<table>
<thead>
<tr>
<th>序列下标</th>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
<th>7</th>
<th>8</th>
<th>9</th>
<th>10</th>
<th>11</th>
<th>12</th>
<th>13</th>
</tr>
</thead>
<tbody>
<tr>
<td>序列数值</td>
<td>13</td>
<td>7</td>
<td>9</td>
<td>16</td>
<td>38</td>
<td>24</td>
<td>37</td>
<td>18</td>
<td>44</td>
<td>19</td>
<td>21</td>
<td>22</td>
<td>63</td>
<td>15</td>
</tr>
<tr>
<td>序列长度</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>链接位置</td>
<td>-1</td>
<td>-1</td>
<td>-1</td>
<td>-1</td>
<td>-1</td>
<td>-1</td>
<td>-1</td>
<td>-1</td>
<td>-1</td>
<td>-1</td>
<td>-1</td>
<td>-1</td>
<td>-1</td>
<td>-1</td>
</tr>
</tbody>
</table>
<blockquote>
<p>第三行表示该序列元素的所能连接的最长不下降子序列的长度，因为本身长度为1，所以初始值都为1。<br>第四行表示链接于哪个序列元素形成最长不下降子序列。</p>
</blockquote>
<h4 id="1-从后向前">1.从后向前</h4><p>先从倒数第二项 63 算起，在它的后面仅有一项，因此仅作一次比较，因为 63 &gt; 15，所以从 63 出发，不作任何链接，长度还是为1。   </p>
<p>再看倒数第三项 22，在它的后面有 2 项，因此必须要在这 2 项当中找出比 22 大，长度又是最长的数值作为链接，由于只有 22 &lt; 63，所以修改 22 的长度为 2，即自身长度加上所链接数值的长度，并修改链接位置为 13，也就是 63 的下标。   </p>
<p>再看倒数第四项 21，在它的后面有 3 项，因此必须要在这3项当中找出比 21 大，长度又是最长的数值作为链接(注意:是长度)，很容易看出，数值 22 满足该条件，因此，修改 21 的长度为3，并修改链接位置为 12，即 22 的序列下标。   </p>
<p>依次类推，最后结果如下表：   </p>
<table>
<thead>
<tr>
<th>序列下标</th>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
<th>7</th>
<th>8</th>
<th>9</th>
<th>10</th>
<th>11</th>
<th>12</th>
<th>13</th>
</tr>
</thead>
<tbody>
<tr>
<td>序列数值</td>
<td>13</td>
<td>7</td>
<td>9</td>
<td>16</td>
<td>38</td>
<td>24</td>
<td>37</td>
<td>18</td>
<td>44</td>
<td>19</td>
<td>21</td>
<td>22</td>
<td>63</td>
<td>15</td>
</tr>
<tr>
<td>序列长度</td>
<td>7</td>
<td>8</td>
<td>7</td>
<td>6</td>
<td>3</td>
<td>4</td>
<td>3</td>
<td>5</td>
<td>2</td>
<td>4</td>
<td>3</td>
<td>2</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>链接位置</td>
<td>3</td>
<td>2</td>
<td>3</td>
<td>7</td>
<td>8</td>
<td>6</td>
<td>8</td>
<td>9</td>
<td>12</td>
<td>10</td>
<td>11</td>
<td>12</td>
<td>-1</td>
<td>-1</td>
</tr>
</tbody>
</table>
<blockquote>
<p>最终状态的转移方程为：f(i) = maxf(j) + 1 (bj &gt; bi 且 i &lt; j)，时间复杂度为 O(n^2)</p>
</blockquote>
<h4 id="2-从前向后">2.从前向后</h4><table>
<thead>
<tr>
<th>序列下标</th>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
<th>7</th>
<th>8</th>
<th>9</th>
<th>10</th>
<th>11</th>
<th>12</th>
<th>13</th>
</tr>
</thead>
<tbody>
<tr>
<td>序列数值</td>
<td>13</td>
<td>7</td>
<td>9</td>
<td>16</td>
<td>38</td>
<td>24</td>
<td>37</td>
<td>18</td>
<td>44</td>
<td>19</td>
<td>21</td>
<td>22</td>
<td>63</td>
<td>15</td>
</tr>
<tr>
<td>序列长度</td>
<td>1</td>
<td>1</td>
<td>2</td>
<td>3</td>
<td>4</td>
<td>4</td>
<td>5</td>
<td>4</td>
<td>6</td>
<td>5</td>
<td>6</td>
<td>7</td>
<td>8</td>
<td>3</td>
</tr>
<tr>
<td>链接位置</td>
<td>-1</td>
<td>-1</td>
<td>1</td>
<td>2</td>
<td>3</td>
<td>3</td>
<td>5</td>
<td>3</td>
<td>6</td>
<td>7</td>
<td>9</td>
<td>10</td>
<td>11</td>
<td>2</td>
</tr>
</tbody>
</table>
<blockquote>
<p>最终状态的转移方程为：f(i) = maxf(j) + 1 (bj &lt; bi 且 i &gt; j)，时间复杂度为 O(n^2)</p>
</blockquote>
<h3 id="代码">代码</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">process.stdin.setEncoding(<span class="string">'utf8'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr = [], <span class="comment">// 接收输入参数的数组</span></span><br><span class="line">    bool = <span class="number">0</span>, <span class="comment">// 判断是否满足输入条件</span></span><br><span class="line">    n = <span class="number">0</span>, <span class="comment">// 数列元素个数</span></span><br><span class="line">    longest = <span class="number">1</span>, <span class="comment">// 最长不下降子序列长度</span></span><br><span class="line">    a = [], <span class="comment">// 数列元素数组</span></span><br><span class="line">    dp = []; <span class="comment">// 动态规划过程中子序列长度数组</span></span><br><span class="line"></span><br><span class="line">process.stdin.on(<span class="string">'readable'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> chunk = process.stdin.read();</span><br><span class="line">    <span class="keyword">if</span>(chunk !== <span class="literal">null</span>) &#123;</span><br><span class="line">        arr.push(chunk.trim());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(bool &gt;= <span class="number">2</span>) &#123;</span><br><span class="line">        n = <span class="built_in">parseInt</span>(arr[<span class="number">0</span>]);</span><br><span class="line">        process.stdin.emit(<span class="string">'end'</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bool++;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">process.stdin.on(<span class="string">'end'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    a = arr.slice(<span class="number">1</span>).join(<span class="string">" "</span>).split(<span class="string">" "</span>).map(<span class="function"><span class="keyword">function</span>(<span class="params">index, elem</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">parseInt</span>(index);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">if</span>(n !== a.length) &#123;</span><br><span class="line">        process.stdout.write(<span class="string">'长度不一致'</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        seq[i] = -<span class="number">1</span>;</span><br><span class="line">        dp[i] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(a[i] &gt; a[j]) &#123;</span><br><span class="line">                dp[i] = <span class="built_in">Math</span>.max(dp[j] + <span class="number">1</span>, dp[i]);</span><br><span class="line">                (<span class="function"><span class="keyword">function</span>(<span class="params">index, arg</span>) </span>&#123;</span><br><span class="line">                    seq[index] = arg;                    </span><br><span class="line">                &#125;)(i, j);</span><br><span class="line">            &#125;</span><br><span class="line">            longest = <span class="built_in">Math</span>.max(dp[i], longest);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`最长长度为：<span class="subst">$&#123;longest&#125;</span>`</span>);</span><br><span class="line"></span><br><span class="line">    process.stdout.write(<span class="string">'end'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h4 id="输入输出">输入输出</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">14&#10;13 7 9 16 38 24 37 18 44 19 21 22 63 15&#10;&#26368;&#38271;&#38271;&#24230;&#20026;&#65306;8&#10;end</span><br></pre></td></tr></table></figure>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/02/03/SSL-TLS/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="Ji Xiang">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="http://o7bp9e1ec.bkt.clouddn.com/1485173143816">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="Ji Xiang's blog">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="Ji Xiang's blog" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/02/03/SSL-TLS/" itemprop="url">
                  SSL/TLS
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-02-03T16:27:50+08:00">
                2017-02-03
              </time>
            

            

            
          </span>

          

          
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="SSL/TLS协议运行机制">SSL/TLS协议运行机制</h2><hr>
<p>互联网的通信安全，建立在 SSL/TLS 协议之上。<br>本文简要介绍 SSL/TLS 协议的运行机制。   </p>
<h3 id="一-作用">一.作用</h3><p>不使用 SSL/TLS 的 HTTP 通信，就是不加密的通信。所有信息明文传播，带来了三大风险：</p>
<pre>
1.窃听风险 
2.篡改风险
3.冒充风险
</pre>

<p>SSL/TLS 协议就是为了解决这三大风险而设计的，希望达到：</p>
<pre>
1.所有信息都是加密传播，第三方无法窃听。
2.具有校验机制，一旦被篡改，通信双方会立刻发现。
3.具有身份证书，防止身份被冒充。
</pre>

<p>互联网是开放环境，通信双方都是未知身份，这为协议的设计带来了很大的难度。而且，协议还必须能够经受所有匪夷所思的攻击，这使得 SSL/TLS 协议变得异常复杂。</p>
<h3 id="二-历史">二.历史</h3><p>互联网加密通信协议的历史，几乎与互联网一样长。</p>
<pre>
1994年，NetScape 公司设计了 SSL 协议1.0版本，但是未发布。
1995年，NetScape 公司发布了 SSL 2.0版，但很快发现有严重漏洞。
1996年，SSL 3.0 版问世，得到大规模应用。
1999年，互联网标准化组织 ISOC 接替 NetScape 公司，发布了 SSL 的升级版 TLS 1.0版。
2006年和2008年，TLS 进行了两次升级，分别是 TLS 1.1版和 TLS 1.2版。
</pre>

<p>目前，应用最广泛的是 TLS 1.0，接下来是 SSL 3.0。但是，主流浏览器都实现了 TLS 1.2的支持。<br>TLS 1.0 通常被标示为 SSL 3.1，TLS 1.1 为 SSL 3.2，TLS 1.2 为 SSL 3.3。</p>
<h3 id="三-基本的运行过程">三.基本的运行过程</h3><p>SSL/TLS 协议的基本思路是采用公钥加密法，也就是说客户端先向服务器端索要公钥，然后用公钥加密信息，服务器接收密文后，用自己的私钥解密。<br>但是，这里有两个问题：</p>
<pre>
1.如何保证公钥不被篡改？
解决方法：将公钥放在数字证书中。只要证书是可信的，公钥就是可信的。

2.公钥加密计算量太大，如何减少耗用的时间？
解决方法：每一次对话（session），客户端和服务器端都生成一个“对话密钥”（session key），用它来加密信息。
由于“对话密钥”是对称加密，所以运算速度非常快，而服务器公钥只用于加密“对话密钥”本身，这样就减少了加密运
算的消耗时间。
</pre>

<p>因此，SSL/TLS协议的基本过程是这样的：</p>
<pre>
1.客户端向服务器端所要并验证公钥。
2.双方协商生成“对话密钥”。
3.双方采用“对话密钥”进行加密通信。
</pre>

<p>上面过程的前两步，又称为“握手阶段”。</p>
<h3 id="四-握手阶段的详细过程">四.握手阶段的详细过程</h3><p>“握手阶段”设计四次通信，我们一个个来看。需要注意的是，“握手阶段”的所有通信都是明文的。</p>
<h4 id="4-1客户端发出请求">4.1客户端发出请求</h4><p>首先，客户端（通常是浏览器）先向服务器发出加密通信的请求，这被叫做 ClientHello 请求。<br>在这一步，客户端主要向服务器提供一下信息：</p>
<pre>
1.支持的协议的版本。
2.一个客户端生成的随机数，稍后用于生成”对话密钥“。
3.支持的加密方法。
4.支持的压缩方法。
</pre>

<p>这里需要注意的是，客户端发送的信息之中不包括服务器的域名。也就是说，理论上服务器只能包含一个网站，否则<br>会分不清应该向客户端提供哪一个网站的数字证书。这就是为什么通常一台服务器只能有一张数字证书的原因。   </p>
<p>对于虚拟主机用户来说，这当然不方便。2006年，TLS协议加入了一个 Server Name Indication 扩展，允许客户<br>端向服务器提供它请求的域名。   </p>
<h4 id="4-2服务器回应">4.2服务器回应</h4><p>服务器收到客户端请求后，向客户端发出回应，这叫做 ServerHello。服务器的回应包含以下内容。</p>
<pre>
1.确认使用的加密通信协议版本。如果浏览器与服务器支持的版本不一致，服务器关闭加密通信。
2.一个服务器生成的随机数，稍后用于生成”对话密钥“。
3.确认使用的加密方法。
4.服务器证书。
</pre>

<p>除了上面这些信息，如果服务器需要确认客户端的身份，就会再包含一项请求，要求客户端提供”客户端证书“。比如，金融机构往往只允许认证客户端连入自己的网络，就会向正式客户提供USB密钥，里面包含了一张客户端证书。   </p>
<h4 id="4-3客户端回应">4.3客户端回应</h4><p>客户端收到服务器回应后，首先验证服务器证书。如果证书不是可信机构颁布，或者证书中的域名与实际域名不一致，或者证书已经过期，就会向访问者显示一个警告，由其选择是否还要继续通信。   </p>
<p>如果证书没有问题，客户端就会从证书中取出服务器的公钥。然后，向服务器发送下面三项信息。</p>
<pre>
1.一个随机数。该随机数用于服务器公钥加密，防止被窃听。
2.编码改变通知，表示随后的信息都用双方商定的加密方法和密钥发送。
3.客户端握手结束通知，表示客户端的握手阶段已经结束。这一项同时也是前面发送的所有内容的 hash 值，用来
供服务器校验。
</pre>

<p>上面第一项的随机数，是整个握手阶段出现的第三个随机数，又称”pre-master key”。有了它以后，客户端和服务器就同时有了三个随机数，接着双方就用事先商定的加密方法，各自生成本次会话所用的同一把”会话密钥”。   </p>
<p>至于为什么一定要用三个随机数，来生成”会话密钥”，解释：   </p>
<blockquote>
<p>“不管是客户端还是服务器，都需要随机数，这样生成的密钥才不会每次都一样。由于SSL协议中证书是静态的，因此十分有必要引入一种随机因素来保证协商出来的密钥的随机性。<br>对于 RSA 密钥交换算法来说，pre-master-key 本身就是一个随机数，再加上 hello 消息中的随机，三个随机数通过一个密钥导出器最终导出一个对称密钥。<br>pre master 的存在在于 SSL 协议不信任每个主机都能产生完全随机的随机数，如果随机数不随机，那么 pre master secret 就有可能被猜出来，那么仅适用 pre master secret 作为密钥就不合适了，因此必须引入新的随机因素，那么客户端和服务器加上 pre master secret 三个随机数一同生成的密钥就不容易被猜出了，一个伪随机可能完全不随机，可是是三个伪随机就十分接近随机了，每增加一个自由度，随机性增加的可不是一。”</p>
</blockquote>
<p>此外，如果前一步，服务器要求客户端证书，客户端会在这一步发送证书及相关信息。   </p>
<h4 id="4-4_服务器的最后回应">4.4 服务器的最后回应</h4><p>服务器收到客户端的第三个随机数 pre-master key 之后，计算生成本次会话所用的”会话密钥”。然后，向客户端最后发送下面信息。</p>
<pre>
1.编码改变通知，表示随后的信息都将用双方商定的加密方法和密钥发送。
2.服务器握手结束通知，表示服务器的握手阶段已经结束。这一项同时也是前面发送的所有内容的 hash 值，用来
供客户端校验。
</pre>

<p>至此，整个握手阶段全部结束。接下来，客户端与服务器进入加密通信，就完全是使用普通的 HTTP 协议，只不过用”会话密钥”加密内容。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/01/23/search-skill/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="Ji Xiang">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="http://o7bp9e1ec.bkt.clouddn.com/1485173143816">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="Ji Xiang's blog">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="Ji Xiang's blog" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/01/23/search-skill/" itemprop="url">
                  Google 搜索引擎技巧
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-01-23T22:36:40+08:00">
                2017-01-23
              </time>
            

            

            
          </span>

          

          
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Google_搜索引擎技巧">Google 搜索引擎技巧</h1><p>1.双引号<br>把搜索词放在双引号中代表完全匹配搜索。</p>
<p>2.减号<br>减号代表搜索不包含减号后面的词，使用这个指令减号前面必须是空格，减号后面没有空格。</p>
<p>3.星号<br>通配符</p>
<p>4.~<br>同时搜索近义词</p>
<p>5.inurl<br>用于搜索查询词出现在url中。支持中文。e.g. inurl:markdown</p>
<p>6.inanchor<br>用于搜索链接锚文字包含搜索词。</p>
<p>7.intitle<br>用于搜索页面title中包含关键词</p>
<p>8.alinurl<br>用于搜索多组查询词出现在url中</p>
<p>9.alintitle<br>用于搜索页面标题中包含多组关键词</p>
<p>10.filetype<br>用于搜索特定文件格式</p>
<p>11.site<br>用来搜索某个域名下的所有文件</p>
<p>12.linkdomain<br>只适用于雅虎，返回的是某个域名的反向链接。</p>
<p>13.related<br>返回的结果是与某个网站有关联的页面。</p>
<p>14.year..year<br>时间段。e.g. 2008..2010，搜索2008年至2010年之间的结果</p>
<p>15.define<br>快速查询字词定义。e.g. define:angary，查询angary的定义</p>
<p>e.g.<br>. inurl:gov 减肥<br>返回的是url中包含gov，页面中有“减肥”这个词的页面</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2016/05/14/团队中的git实践/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="Ji Xiang">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="http://o7bp9e1ec.bkt.clouddn.com/1485173143816">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="Ji Xiang's blog">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="Ji Xiang's blog" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/05/14/团队中的git实践/" itemprop="url">
                  团队中的git实践
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-05-14T20:50:07+08:00">
                2016-05-14
              </time>
            

            

            
          </span>

          

          
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>为了获得软件质量和开发效率的双重收益，软件项目开发早已不再是一个人的事情了，而是一个团队(team)的事情。不但如此，现今的软件开发规模越来越大，所涉及的技术门类也越来越复杂，一个人难以独挑大梁，同时，一个人也难以在短周期内完成复杂项目。团队的意义不仅在于提高开发效率，更能保证开发质量，一人负责一块开发内容就可以用充足的精力和热情使这块内容做的更加完美。<br>说到团队开发，总是离不开项目管理和版本控制工具，这里我们将会讨论版本控制工具——git在团队中正确实践的姿势。<br>Git/Github是任何一个非小白程序员都知道或使用的工具/网站，随着软件开发学龄的深入，我自己的体会是越来越离不开这个东西了。一个人用git可以用得随心所欲，但团队中就是另外一回事了。一个人的项目，代码怎么改、怎么提交都不会有冲突，这样也会养成一些不良习惯，把这些习惯带到团队开发中，轻则让队友讨厌，重则酿成大祸（这不是危言耸听）。   </p>
<h3 id="1-习惯养成">1.习惯养成</h3><p>如果一个团队在使用git时没有一些规范，那将是一场难以醒来的噩梦！然而，规范固然重要，但更重要的是个人素质，在使用git时需要自己养成良好的习惯。</p>
<h3 id="2-提交">2.提交</h3><p>Commit Message格式   </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#60;type&#62;(&#60;scope&#62;): &#60;subject&#62;&#10;&#60;space&#62;&#10;&#60;body&#62;&#10;&#60;space&#62;&#10;&#60;footer&#62;</span><br></pre></td></tr></table></figure>
<p>上面是一次提交后Message格式规范，分成标题、内容详情、结尾三个部分，各有各的用处。<br>头部即首行，是可以直接在页面中预览的部分，一共有三个部分<type>, <scope>, <subject>, 含义分别如下：</subject></scope></type></p>
<p><em>Type</em>   </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- feat: &#26032;&#21151;&#33021;(feature)&#10;- fix: &#20462;&#34917;bug&#10;- docs: &#25991;&#26723;(documentation)&#10;- style: &#26684;&#24335;(&#19981;&#24433;&#21709;&#20195;&#30721;&#36816;&#34892;&#30340;&#21464;&#21160;)&#10;- refactor: &#37325;&#26500;(&#21363;&#19981;&#26159;&#26032;&#22686;&#21151;&#33021;&#65292;&#20063;&#19981;&#26159;&#20462;&#25913;bug&#30340;&#20195;&#30721;&#21464;&#21160;)&#10;- test: &#22686;&#21152;&#27979;&#35797;&#10;- chore: &#26500;&#24314;&#36807;&#31243;&#25110;&#36741;&#21161;&#24037;&#20855;&#30340;&#21464;&#21160;</span><br></pre></td></tr></table></figure>
<p><em>Scope</em>   </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#29992;&#26469;&#35828;&#26126;&#26412;&#27425;&#25552;&#20132;&#24433;&#21709;&#30340;&#33539;&#22260;&#65292;&#21363;&#31616;&#35201;&#35828;&#26126;&#20462;&#25913;&#20250;&#28041;&#21450;&#30340;&#37096;&#20998;&#12290;</span><br></pre></td></tr></table></figure>
<p><em>Subject</em></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#29992;&#26469;&#31616;&#35201;&#25551;&#36848;&#26412;&#27425;&#25913;&#21160;&#65292;&#27010;&#36848;&#23601;&#22909;&#20102;&#65292;&#22240;&#20026;&#21518;&#38754;&#36824;&#20250;&#22312;Body&#37324;&#32473;&#20986;&#20855;&#20307;&#20449;&#24687;&#12290;&#24182;&#19988;&#26368;&#22909;&#36981;&#24490;&#10;&#19979;&#38754;&#19977;&#26465;&#65306;&#10; - &#20197;&#21160;&#35789;&#24320;&#22836;&#65292;&#20351;&#29992;&#31532;&#19968;&#20154;&#31216;&#29616;&#22312;&#26102;&#10; - &#39318;&#23383;&#27597;&#19981;&#35201;&#22823;&#20889;&#10; - &#32467;&#23614;&#19981;&#29992;&#21477;&#21495;( . )</span><br></pre></td></tr></table></figure>
<p><em>Body</em>   </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#60;body&#62;&#37324;&#30340;&#20869;&#23481;&#26159;&#23545;&#19978;&#38754;subject&#37324;&#20869;&#23481;&#30340;&#23637;&#24320;&#65292;&#22312;&#27492;&#20316;&#26356;&#21152;&#35814;&#23613;&#30340;&#25551;&#36848;&#65292;&#20869;&#23481;&#37324;&#24212;&#35813;&#21253;&#25324;&#20462;&#25913;&#21160;&#26426;&#21644;&#20462;&#25913;&#21069;&#21518;&#30340;&#23545;&#27604;&#12290;</span><br></pre></td></tr></table></figure>
<p><em>Footer</em>   </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#60;footer&#62;&#37324;&#20027;&#35201;&#25918;&#32622;&#19981;&#20860;&#23481;&#21464;&#26356;&#21644;Issue&#20851;&#38381;&#30340;&#20449;&#24687;&#12290;</span><br></pre></td></tr></table></figure>
<h4 id="Revert">Revert</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#27492;&#22806;&#22914;&#26524;&#38656;&#35201;&#25764;&#38144;&#20043;&#21069;&#30340;&#25552;&#20132;&#65292;&#37027;&#20040;&#26412;&#27425;&#25552;&#20132;Message&#20013;&#24517;&#39035;&#20197;revert: &#24320;&#22836;&#65292;&#21518;&#38754;&#32039;&#36319;&#21069;&#38754;&#25551;&#36848;&#30340;Header&#37096;&#20998;&#65292;&#26684;&#24335;&#19981;&#21464;&#12290;</span><br></pre></td></tr></table></figure>
<p>在具体开发工作中主要需要遵守的原则就是[使每次提交都有质量]，只要坚持做到以下几点：</p>
<ol>
<li>提交时的粒度是一个小功能点或者一个bug fix，这样进行恢复等操作时能够将[误伤]减到最低；</li>
<li>用一句简练的话写在第一行，然后空一行稍微详细阐述提交所增加或修改的地方；</li>
<li>不要没提交一次就推送一次，多积攒几个提交后一次性推送，这样可以避免在进行一次提交后发现代码中还有小错误。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#21152;&#20837;&#20195;&#30721;&#24050;&#32463;&#25552;&#20132;&#20102;&#65292;&#23545;&#36825;&#27425;&#25552;&#20132;&#30340;&#20869;&#23481;&#36827;&#34892;&#26816;&#26597;&#26102;&#21457;&#29616;&#37324;&#38754;&#26377;&#20010;&#21464;&#37327;&#21333;&#27425;&#25340;&#38169;&#20102;&#25110;&#32773;&#20854;&#20182;&#22833;&#35823;&#65292;&#21482;&#35201;&#36824;&#27809;&#26377;&#25512;&#36865;&#21040;&#36828;&#31243;&#65292;&#10;&#23601;&#26377;&#19968;&#20010;&#19981;&#34987;&#20182;&#20154;&#21457;&#35273;&#20320;&#30340;&#30095;&#24573;&#30340;&#34917;&#25937;&#26041;&#27861;&#8212;&#8212;   &#10;&#39318;&#20808;&#65292;&#25226;&#22833;&#35823;&#20462;&#27491;&#20043;&#21518;&#25552;&#20132;&#65292;&#21487;&#20197;&#29992;&#19982;&#19978;&#27425;&#25552;&#20132;&#30456;&#21516;&#30340;Message&#12290;   &#10;&#28982;&#21518;&#65292;&#32456;&#31471;&#20013;&#25191;&#34892;&#60;code&#62;git rebase -i [SHA]&#60;/code&#62;&#65292;&#20854;&#20013;SHA&#26159;&#19978;&#19968;&#27425;&#25552;&#20132;&#20043;&#21069;&#30340;&#37027;&#27425;&#25552;&#20132;&#30340;&#12290;   &#10;&#26368;&#21518;&#65292;&#36825;&#26679;&#23601;&#23558;&#20004;&#27425;&#25552;&#20132;&#30340;&#33410;&#28857;&#21512;&#24182;&#25104;&#19968;&#20010;&#65292;&#29978;&#33267;&#33021;&#22815;&#20462;&#25913;&#25552;&#20132;&#20449;&#24687;&#12290;</span><br></pre></td></tr></table></figure>
<h3 id="3-推送">3.推送</h3><p>当自己一个人进行开发时，在功能完成之前不要急着创建远程分支。   </p>
<h3 id="4-拉取和合并">4.拉取和合并</h3><p>在将其他分支的代码合并到当前分支时，如果那个分支是当前分支的父分支，为了保持图表的可读性和可追踪性，<br>可以考虑用 git rebase 来代替 git merge；反过来或者不是父子关系的两个分支以及互相已经 git merge 过的分支，<br>就不要采用 git rebase 了，避免出现重复的冲突和提交节点。   </p>
<h3 id="最后献上一句话">最后献上一句话</h3><p>日拱一卒，功不唐捐。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2016/05/03/数字证书基础知识/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="Ji Xiang">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="http://o7bp9e1ec.bkt.clouddn.com/1485173143816">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="Ji Xiang's blog">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="Ji Xiang's blog" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/05/03/数字证书基础知识/" itemprop="url">
                  数字证书基础知识
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-05-03T14:54:44+08:00">
                2016-05-03
              </time>
            

            

            
          </span>

          

          
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>在为了更好地理解其中证书的特性，这里对数字证书以及相关的知识进行了整理和总结。</p>
</blockquote>
<p>在讲数字证书之前必须要讲<b>非对称加密算法</b>和<b>摘要算法</b>，因为数字证书的基础就是各种加解密算法(非对称加密、<br>摘要算法)，而其中的核心就是非对称加密算法了。目前而言加密方法可以分为两大类，一类是<b>单钥加密</b><br>(private key cryptography)也可以称为对称加密，还有一类叫做双钥加密(public key cryptography)也可以称为非对称加密。<br>前者的加密和解密过程都用同一套密码，后者的加密和解密过程用的是不同的密码。</p>
<h1 id="加密算法">加密算法</h1><h3 id="1-对称加密">1.对称加密</h3><p>对称加密(也叫私钥加密)指加密和解密使用相同密钥的加密算法。有时又叫传统密码算法，就是加密密钥能够从解密密钥中推算出来，<br>同时解密密钥也可以从加密密钥中推算出来。而在大多数的对称算法中，加密密钥和解密密钥是相同的，所以也称这种加密算法为秘密<br>密钥算法或单密钥算法。   </p>
<p>在应用该算法时，它要求发送方和接收方在安全通信之前，商定一个密钥。对称算法的安全性依赖于密钥，泄漏密钥就意味着任何人都<br>可以对他们发送或接收的消息解密，所以密钥的保密性对通信性至关重要。对称加密算法的特点是算法公开、计算量小、加密速度快、<br>加密效率高。对称加密有很多种算法，由于它效率很高，所以被广泛使用在很多加密协议的核心当中。不足之处是，交易双方都使用同<br>样钥匙，安全性得不到保证。   </p>
<h3 id="2-常见的对称加密算法">2.常见的对称加密算法</h3><ul>
<li><p>DES：数据加密标准(DES，Data Encryption Standard)是一种使用密钥加密的块密码，它基于使用56位密钥的对称算法，这个<br>算法因为包含一些机密设计元素，相对短的密钥长度以及被怀疑内含美国国家安全局(NSA)的后门而在开始时是有争议的，DES现在<br>已经不被视为一种安全的加密算法，主要因为它使用的56位密钥过短，导致容易被破解。为了提供实用所需的安全性，可以使用DES的<br>派生算法3DES来进行加密，虽然3DES也存在理论上的攻击方法。</p>
</li>
<li><p>AES：高级加密标准(英语：Advanced Encryption Standard，缩写：AES)，这个标准用来替代原先的DES，已经被多方分析<br>且广为全世界所使用，2006年，高级加密标准已然成为对称密钥加密中最流行的算法之一。AES的区块长度固定为128比特，密钥<br>长度则可以是128，192或256比特。</p>
</li>
<li><p>RC4：RC4加密算法是大名鼎鼎的RSA三人组中的头号人物Ronald Rivest在1987年设计的密钥长度可变的流加密算法簇。该算法<br>的速度可以达到DES加密的10倍左右，且具有很高级别的非线性。RC4起初是用于保护商业机密的。但是在1994年9月，它的算法被<br>发布在互联网上，也就不再有什么商业机密了。</p>
</li>
<li><p>是旅居瑞士中国青年学者来学嘉和著名密码专家J.Massey于1990年提出的。它在1990年正式公布并在以后得到增强。这种算法是<br>在DES算法的基础上发展出来的，类似于三重DES，和DES一样IDEA也是属于对称密钥算法。发展IDEA也是因为感到DES具有密钥太短<br>等缺点，已经过时。IDEA的密钥为128位，这么长的密钥在今后若干年内应该是安全的。</p>
</li>
</ul>
<h3 id="3-非对称加密">3.非对称加密</h3><p>与对称加密算法不同，非对称加密算法需要两个密钥：公开密钥(publickey)和私有密钥(privatekey)；并且加密密钥和解密密钥<br>是成对出现的。非对称加密算法在加密和解密过程使用了不同的密钥，非对称加密也称为公钥加密，在密钥对中，其中一个密钥是对外公开的，<br>所有人都可以获取到，称为公钥，其中一个密钥是不公开的称为私钥。</p>
<h3 id="4-非对称加密的特性">4.非对称加密的特性</h3><ul>
<li><p>对于一个公钥，有且只有一个对应的私钥。</p>
</li>
<li><p>公钥是公开的，并且不能通过公钥反推出私钥。</p>
</li>
<li><p>通过私钥加密的密文只能通过公钥能解密，通过公钥加密的密文也只能通过私钥能解密。</p>
</li>
</ul>
<blockquote>
<p>通过公钥是极难推算出私钥的，只能通过穷举，所以只要密钥足够长，要想从公钥推算出私钥几乎不可能的。</p>
</blockquote>
<h3 id="5-非对称加密的主要用途">5.非对称加密的主要用途</h3><p>对信息保密，防止中间人攻击：将明文使用公钥加密，传输给接收者，这样确保信息只能被有私钥的拥有者解密，其他人无法获得明文信息，<br>因为没有私钥无法进行解密。该方法一般用于交换对称密钥。身份验证和防止信息篡改：私钥拥有者使用私钥加密一段授权明文，并将授权<br>明文和加密后的密文，以及公钥一并发送出来，接收方只需要通过公钥将密文解密后与授权明文对比是否一致，就可以判断明文在中途是否<br>被篡改过。此方法用于数字签名。</p>
<h3 id="6-常见的非对称加密算法">6.常见的非对称加密算法</h3><ul>
<li><p>RSA：1977年，三位数学家Rivest、Shamir 和 Adleman 设计了一种算法，可以实现非对称加密。这种算法用他们三个人的名字命名，叫做RSA算法。<br>从那时直到现在，RSA算法一直是最广为使用的”非对称加密算法”。毫不夸张地说，只要有计算机网络的地方，就有RSA算法。这种算法非常可靠，<br>密钥越长，它就越难破解。根据已经披露的文献，目前被破解的最长RSA密钥是768个二进制位。也就是说，长度超过768位的密钥，还无法破解(至少没人公开宣布)。<br>因此可以认为，1024位的RSA密钥基本安全，2048位的密钥极其安全。适用于数字签名和密钥交换。 该算法是目前应用最广泛的公钥加密算法，特别适用于通过 Internet 传送的数据。</p>
</li>
<li><p>DSA：数字签名算法 (Digital Signature Algorithm, DSA) 由美国国家安全署 (United States National Security Agency, NSA) 发明，<br>已作为数字签名的标准。在DSA数字签名和认证中，发送者使用自己的私钥对文件或消息进行签名，接受者收到消息后使用发送者的公钥来验证签名的真实性。DSA只是一种算法，<br>和RSA不同之处在于它不能用作加密和解密，也不能进行密钥交换，只用于签名，它比RSA要快很多。DSA 算法的安全性取决于自计算离散算法的困难。这种算法，不适用于数据加密，<br>仅适用于数字签名。</p>
</li>
<li><p>Diffie-Hellman：一种确保共享KEY安全穿越不安全网络的方法。Whitefield与Martin Hellman在1976年提出了一个奇妙的密钥交换协议，<br>称为Diffie-Hellman密钥交换协议/算法(Diffie-Hellman Key Exchange/Agreement Algorithm)。这个机制的巧妙在于需要安全通信的双方可以用这个方法确定对称密钥。<br>然后可以用这个密钥进行加密和解密。但是注意，这个密钥交换协议/算法只能用于密钥的交换，而不能进行消息的加密和解密。双方确定要用的密钥后，要使用其他对称密钥操作<br>加密算法实际加密和解密消息。该算法仅适用于密钥交换。</p>
</li>
<li><p>ECC：椭圆加密算法(ECC)是一种公钥加密体制，最初由Koblitz和Miller两人于1985年提出，与经典的RSA，DSA等公钥密码体制相比，<br>椭圆密码体制有以下优点：160位的椭圆密钥与1024位的RSA密钥安全性相同；在私钥的加密解密速度上，ECC算法比RSA、DSA速度更快；存储空间占用小；带宽要求低；<br>ECC算法的数学理论非常深奥和复杂，在工程应用中比较难于实现，但它的单位安全强度相对较高。</p>
</li>
</ul>
<p>非对称加密算法可能是世界上最重要的算法，它是当今电子商务等领域的基石。非对称加密算法如此强大可靠，却有一个弊端，就是加解密比较耗时。<br>因此，在实际使用中，往往与对称加密和摘要算法结合使用。列如在实体之间交换对称密钥时，或者在签署一封邮件的散列时(数字签名)。</p>
<blockquote>
<p>散列是通过应用一种单向数学函数获得的一个定长结果，对于数据而言，叫做散列算法。</p>
</blockquote>
<h3 id="7-摘要算法">7.摘要算法</h3><p>摘要算法是一个神奇的算法，也称为散列或者散列值。是一种与基于密钥(对称密钥或公钥)的加密不同的数据转换类型。散列就是通过把一个叫做散列算法的单向数学函数应用于数据，将任意长度的一块数据转换为一个定长的、不可逆转的数字，其长度通常在128～256位之间。所产生的散列值的长度应足够长，因此使找到两块具有相同散列值的数据的机会很少。</p>
<h3 id="8-摘要算法具有以下特性：">8.摘要算法具有以下特性：</h3><ul>
<li><p>只要源文本不同，计算得到的结果，必然不同(或者说机会很少)。</p>
</li>
<li><p>无法从结果反推出源数据(那是当然的，不然就能量不守恒了)。</p>
</li>
</ul>
<h3 id="9-常见的摘要算法：">9.常见的摘要算法：</h3><ul>
<li><p>MD5：是RSA数据安全公司开发的一种单向散列算法，MD5被广泛使用，可以用来把不同长度的数据块进行暗码运算成一个固定位位的数值(通常是128位)。</p>
</li>
<li><p>SHA-1：与 DSA 公钥算法相似，安全散列算法1(SHA-1)也是由 NSA 设计的，并由 NIST 将其收录到 FIPS 中，作为散列数据的标准。它可产生一个 160 位的散列值。SHA-1 是流行的用于创建数字签名的单向散列算法。</p>
</li>
<li><p>MAC(Message Authentication Code)：消息认证代码，是一种使用密钥的单向函数，可以用它们在系统上或用户之间认证文件或消息，常见的是HMAC(用于消息认证的密钥散列算法)。</p>
</li>
<li><p>CRC(Cyclic Redundancy Check)：循环冗余校验码，CRC校验由于实现简单，检错能力强，被广泛使用在各种数据校验应用中。占用系统资源少，用软硬件均能实现，是进行数据传输差错检测地一种很好的手段(CRC 并不是严格意义上的散列算法，但它的作用与散列算法大致相同，所以归于此类)。</p>
</li>
</ul>
<p>摘要算法用于对比信息源是否一致，因为只要源数据发生变化，得到的摘要必然不同。因为通常结果比源数据要短很多，所以称为“摘要”。</p>
<p>应用场景，如发件人生成邮件的散列值并加密它，然后将它与邮件本身一起发送。而收件人同时解密邮件和散列值，并由接收到的邮件产生另外一个散列值，然后将两个散列值进行比较。如果两者相同，邮件极有可能在传输期间没有发生任何改变。</p>
<h3 id="10-数字签名">10.数字签名</h3><p>数字签名就是对非对称加密和摘要算法的一种应用，能够确保信息在发布后不会被篡改(摘要算法特性)，保证数据的完整性和可信性；同时也可以防止数据被他人伪造(非对称加密算法特性)；列如，我们有一段授权文本需要发布时，为了防止中途篡改发布的内容，保证发布文本的完整性，以及文本是由指定的发布者发布的。那么，可以通过摘要算法得到发布内容的摘要，得到摘要之后，发布者使用私钥加密得到密文(签名)，这时候将源文本、密文(签名)以及公钥一起发布出去即可。</p>
<p>验证过程为：首先验证公钥是否是发布者的公钥，然后用公钥对密文进行解密，得到摘要，使用发布者对文本同样的摘要算法得到摘要文本，比对摘要是否一致即可确认信息是否被篡改或者是指定发布者发布的。</p>
<h1 id="数字证书">数字证书</h1><h3 id="1-现实生活中的证书">1.现实生活中的证书</h3><p>在现实生活中，证书顾名思义，就是权限机构颁发的证明。比如英语6级证书，就是教育部门颁发给通过了6级考核的个人的证明，证明这个人的英语能力。我们来看一下这个证书的组成：</p>
<ul>
<li><p>被证明人：老王</p>
</li>
<li><p>内容：通过了英语六级</p>
</li>
<li><p>盖章：教育部门的公章或钢印</p>
</li>
</ul>
<p>当老王用这张证书找工作时，用人单位会通过查看证书的各项内容(尤其是公章)，来验证证书的合法性和老王的能力。在现实生活中经常有假的6级证书，这些假证书最重要的就是有一个假公章。现实生活中使用法律法规来约束私刻假公章的行为，但是用人单位可能不能十分准确的判断公章是真是假。而数字签字可以来解决该类问题。</p>
<h2 id="2-数字证书">2.数字证书</h2><p>数字证书就是通过数字签名实现的数字化的证书，在现实生活中公章可以被伪造，但是在计算数字世界中，数字签名是没办法被伪造的，比如上述证书中，在一个证书文件中写明了证书内容，颁发证书时，教育部门用他们的私钥对文件的摘要信息进行签名，将签名和证书文件一起发布，这样就能确保该证书无法被伪造。验证证书是否合法时，首先用教育部门的公钥(公钥是公开的谁都可以获取到)对签名进行解密得到一个摘要信息，使用教育部门同样的摘要算法得到证书的另一个摘要信息，对比两个摘要信息是否一致就能确定该证书是否合法。在一般的证书组成中部分中，还加入了一些其他信息，比如证书的有效期。</p>
<p>数字证书也有很多的签发机构，不同的签发机构签发的证书，用途也是不一样的，比如iOS开发中，使用到的ipa文件签名证书，需要到苹果申请。而在Web访问中为了防止Web内容在网络中安全传输，需要用到的SSL证书则需要向几家公认的机构签发。这些签发机构统称为CA(Certificate Authority)。</p>
<p>Web访问相关的证书可以向国际公认的几个机构：</p>
<ul>
<li><p>WebTrust</p>
</li>
<li><p>GlobalSign</p>
</li>
<li><p>GTE</p>
</li>
<li><p>Nortel</p>
</li>
<li><p>Verisign</p>
</li>
</ul>
<h3 id="3-数字证书的验证">3.数字证书的验证</h3><p>申请证书是为了验证，比如Web应用相关的SSL证书验证方是浏览器，iOS各种证书的验证方是iOS设备。因为数字证书是基于数字签名的，所有数字证书的合法性验证就是验证数字证书的签名是否正确，对于签名的验证在是需要签发机构的公钥才能验证；</p>
<p>对于iOS开发证书来说，申请完签名证书后，还需要安装苹果的公钥证书(XCode安装后会自动安装)，这样才能确保我们申请的证书是可以被验证通过的(合法的)，可用来进行ipa文件签名的。对于Web相关的证书签名的验证，则是由浏览器来验证，对于国际公认的几个证书签发机构浏览器会内置其公钥证书，用来验证数字证书的可信性。</p>
<p>当数字证书通过验证后，便可以用数字证书做对应的事情，iOS开发证书可以用来对APP进行签名，SSL证书可以用来做Web内容加密处理相关的事情。所以有了这些证书之后，能保证在数据的传输过程中，数据是不会被篡改的，并且信息来源也是不能不修改的，从而确保信息安全。</p>
<blockquote>
<p>对于iOS，iOS系统已经将这个验证过程固化在系统中了，除非越狱，否则无法绕过</p>
</blockquote>
<h3 id="4-数字证书的授权链">4.数字证书的授权链</h3><p>数字证书还包含一个授权链信息，举个例子：如果你要申请休假1周，需要你的上司审批，你的上司需要他的上司同意，最终需要大老板同意，那么这一层层的授权，形成了一个授权链，大老板是授权链的根(root)，中间这些环节分别是被更接近root的人授权的。</p>
<p>比如苹果开发者的APP签名证书，该证书可以用来对APP进行签名，该证书实际上是由苹果的Worldwide Developer Relations Certificate Authority(WDRCA)授权签名的，而它是由Apple Certificate Authority授权签名的。在这个关系链中苹果的CA是根。 苹果CA根证书默认是内置在苹果系统中的，所以WDRCA的可信性可以由苹果内置的CA根证书来验证其可信性。</p>
<p>Web相关的SSL证书顶部CA根，则就是上述提到的几家公认的签发机构，当我们需要Web做SSL的证书时，便可以向上述机构申请，通常向根机构申请费用都会比较高，也可以向一些二级授权机构进行申请，选择根机构证书签发的好处就是目前大多数的浏览器都会预装内置了这些权威CA的公钥证书，这样，在使用这些权威CA签发过的证书的时候，浏览器一般不会报风险提示。</p>
<h1 id="总结">总结</h1><p>数字证书签名的基础是非对称加密算法，利用了非对称加密的身份验证和防止信息篡改的特性来实现的，在一些其他方面比如HTTPS中密钥交换用的就是非对称加密的保密特性来实现的，在非对称加密算法中RSA应用最广。非对称加密虽好，但却有一个弊端，就是加解密比较耗时，所以一般都是配合对称加密一起使用。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2016/03/31/course-note-3/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="Ji Xiang">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="http://o7bp9e1ec.bkt.clouddn.com/1485173143816">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="Ji Xiang's blog">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="Ji Xiang's blog" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/03/31/course-note-3/" itemprop="url">
                  信息系统管理与安全(3)
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-03-31T13:42:40+08:00">
                2016-03-31
              </time>
            

            

            
          </span>

          

          
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="信息安全">信息安全</h2><h3 id="资产管理：责任划分">资产管理：责任划分</h3><h3 id="编制资产清单：">编制资产清单：</h3><ul>
<li>识别所有资产   </li>
<li>对资产的所有权、信息进行分类，并形成文件   </li>
<li>资产清单内容：资产类型、格式、位置、备份信息、许可信息、业务价值   </li>
</ul>
<h3 id="明确资产所有权：">明确资产所有权：</h3><ul>
<li>与信息处理有关的所有信息资产都应当由指定的部门   </li>
</ul>
<h3 id="资产的使用">资产的使用</h3><ul>
<li>应当明确信息资产的使用规划，并形成文件，加以实施   </li>
</ul>
<h3 id="风险因素评估：信息资产评估">风险因素评估：信息资产评估</h3><blockquote>
<p>根据客户的行业特点、应用特性的安全目标，信息资产的赋值形式：   </p>
<ul>
<li>形式一：为机密性、完整性、可用性分别赋予不同的价值等级   </li>
<li>形式二：依据机密性、完整性、可用性赋予等级，经过综合评定得出资产价值   </li>
<li>形式三：用相对信息价值的货币来衡量   </li>
</ul>
</blockquote>
<h3 id="资产的机密性赋值参考">资产的机密性赋值参考</h3><ul>
<li>3 高   </li>
<li>2 中等   </li>
<li>1 低   </li>
<li>0 可忽略   </li>
</ul>
<h3 id="资产的重要性等级划分参考">资产的重要性等级划分参考</h3><ul>
<li>4 高 严重损失   </li>
<li>3 中 中等程度损失   </li>
<li>2 低   </li>
<li>1 很低   </li>
</ul>
<h3 id="信息资产价值的货币化表示">信息资产价值的货币化表示</h3><h3 id="威胁分析">威胁分析</h3><ul>
<li>潜在威胁分析   </li>
<li>威胁审计和入侵检测   </li>
<li>安全威胁综合分析   </li>
</ul>
<h3 id="威胁来源于识别">威胁来源于识别</h3><blockquote>
<p>外在<br>环境因素   </p>
<ul>
<li>自然环境   </li>
<li>物流环境   </li>
<li>人文环境<br>人为因素   </li>
<li>无恶意内部人员   </li>
<li>有恶意内部人员   </li>
<li>第三方   </li>
<li>外部人员<br>内在   <ul>
<li>任务确定   </li>
<li>系统设计   </li>
</ul>
</li>
</ul>
</blockquote>
<h3 id="威胁发生的可能性">威胁发生的可能性</h3><ul>
<li>应根据经验和有关统计数据判断威胁发生的频率或概率   </li>
<li>影响威胁发生可能性的因素：   <ul>
<li>资产的吸引力   </li>
<li>组织的知名度   </li>
<li>资产转换成利益的容易程度   </li>
<li>威胁的技术力量   </li>
<li>脆弱性被利用的难易程度   </li>
</ul>
</li>
<li>有关统计信息获取的取到包括   <ul>
<li>依赖历史纪录或安全事件报告   </li>
<li>通过各种设备，获取威胁发生的数据统计和分析结果   </li>
<li>各种日志中威胁发生的数据统计和分析结果   </li>
<li>近年来权威机构发布的报告   </li>
</ul>
</li>
</ul>
<h3 id="威胁产生的影响">威胁产生的影响</h3><ul>
<li>对威胁发生概率和产生影响的评估结论是识别和确定每种威胁发生风险的等级   <ul>
<li>先确定没有控制措施条件下威胁所产生的影响，建立基本风险基线   </li>
<li>考虑已有控制措施对威胁可能产生的阻碍作用，确定风险级别   </li>
</ul>
</li>
</ul>
<h3 id="脆弱性分类">脆弱性分类</h3><p>技术脆弱性：物理安全、网络安全、系统安全、应用安全<br>管理脆弱性：安全管理   </p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2016/03/28/course-note-2/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="Ji Xiang">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="http://o7bp9e1ec.bkt.clouddn.com/1485173143816">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="Ji Xiang's blog">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="Ji Xiang's blog" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/03/28/course-note-2/" itemprop="url">
                  信息系统管理与安全(2)
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-03-28T15:28:06+08:00">
                2016-03-28
              </time>
            

            

            
          </span>

          

          
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="信息安全风险基本要素">信息安全风险基本要素</h1><ul>
<li>信息资产 <strong>增加风险</strong></li>
<li>信息资产环境或其自身存在的脆弱性/漏洞 <strong>增加风险</strong></li>
<li>威胁 <strong>增加风险</strong></li>
<li>安全控制措施 <strong>降低风险</strong></li>
<li>影响 <strong>增加风险</strong></li>
</ul>
<h1 id="信息安全风险模型">信息安全风险模型</h1><h1 id="信息安全风险评估模型的作用">信息安全风险评估模型的作用</h1><blockquote>
<p>可以建立信息安全风险各个要素之间的相互关系，据此可以分析系统内部机制中所存在的危险性因素，可以发现系统与外界环境交互过程中存在的不正常和有害行为，从而完成对系统脆弱点和安全威胁的定性分析。<br>可以进一步采用其他方法来进行风险建模。</p>
</blockquote>
<h1 id="风险评估准备">风险评估准备</h1><ul>
<li>确定风险评估的目标</li>
<li>确定风险评估的范围</li>
<li>选择与组织相适应的风险判断方法</li>
<li>建立风险…</li>
</ul>
<h1 id="资产及其价值">资产及其价值</h1><h2 id="资产是组织赋予了价值，且需要保护的东西">资产是组织赋予了价值，且需要保护的东西</h2><ul>
<li>能以多种形式存在</li>
<li>价值和安全属性具有很强的时间特性<h2 id="资产赋值是对资产安全价值的估价">资产赋值是对资产安全价值的估价</h2><h2 id="资产的价值与如下因素有关：">资产的价值与如下因素有关：</h2></li>
<li>自身的价值</li>
<li>对业务的安全重要性</li>
<li>在一定条件下的潜在价值</li>
<li>与之相关的安全保护措施</li>
</ul>
<h1 id="资产管理">资产管理</h1><ul>
<li>根据不同的项目目标和特点，确定重要识别的资产类别</li>
<li>明确所拥有和需要保护的信息资产，确定关键资产</li>
<li>资产管理的目标是实现并保持组织资产的适当保护<h1 id="资产管理分类">资产管理分类</h1>指导原则：</li>
<li>组织价值、法律要求、敏感性、关键性</li>
<li>权衡分类数量</li>
<li>按保护级别进行</li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2016/03/27/JavaScript学习笔记-3/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="Ji Xiang">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="http://o7bp9e1ec.bkt.clouddn.com/1485173143816">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="Ji Xiang's blog">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="Ji Xiang's blog" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/03/27/JavaScript学习笔记-3/" itemprop="url">
                  JavaScript学习笔记(3)
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-03-27T16:47:19+08:00">
                2016-03-27
              </time>
            

            

            
          </span>

          

          
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="JavaScript_Closure">JavaScript Closure</h1><p>学习JavaScript，不能不知道<b>闭包(closure)</b>的概念和作用。闭包是JavaScript中重要的一个概念，对于初学者来讲，闭包很难理解和运用。但只有理解了闭包的基本概念，才能正确的使用它；同样的，只有配合正确的实践，我们才有更加深刻的理解。因此，这片文章借鉴了很多前人的总结和经验，只为更好的理解闭包。   </p>
<h2 id="闭包的概念">闭包的概念</h2><p>对于码农来说，学习一门新技术，除了看官方API和相关文档，示例代码的对我们的帮助可能更大，因为代码的运行结果更加直观，能加深我们的理解。下面贴出大牛的代码，号称世上最简单的闭包：   </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">A</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">B</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Hello closure!'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> B;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> c = A();</span><br><span class="line"><span class="comment">// c(); Hello closure!</span></span><br></pre></td></tr></table></figure>
<p>确实，这个示例代码真的不能再简单了。这段代码“翻译”后可以表示为：   </p>
<ol>
<li>定义了一个函数A   </li>
<li>在A中定义了内部函数B   </li>
<li>在A中返回B（确切的讲，在A中返回B的引用）   </li>
<li>执行A()，把A的返回值-函数B()的引用复制给变量c   </li>
<li>执行 函数B()，输出结果</li>
</ol>
<p>根据上述例子，闭包可定义为：<br><em>当一个内部函数被其外部函数之外的变量引用时，就形成了一个闭包。</em></p>
<h2 id="闭包的作用">闭包的作用</h2><p>在了解闭包的作用之前，我们先了解一下JavaScript中的垃圾回收(GC)机制：<em>在JavaScript中，如果一个对象不再被引用，那么这个对象就会被GC回收，否则这个对象会一直保存在内存中。</em><br>在上述例子中，B定义在A中，因此B依赖于A，而外部变量c获得了内部函数B的引用，也就是说，A被间接引用了，所以A不会被GC回收，而是一直保持上下文，在同一个引用调用结束前，会一直保存在内存中，直到调用结束。<br>示例2：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">A</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> count = <span class="number">0</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">B</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    count++;</span><br><span class="line">    <span class="built_in">console</span>.log(count);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> B;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> c = A();</span><br><span class="line">c();<span class="comment">//1</span></span><br><span class="line">c();<span class="comment">//2</span></span><br><span class="line">c();<span class="comment">//3</span></span><br></pre></td></tr></table></figure>
<p>count是A中的一个变量，它的值在B中被改变，函数B每执行一次，count的值在原来的基础上累加1，A被变量c引用，不会被GC，因此，A中的count一直保存在内存中，c每执行一次，由于保留了上下文，count的值会在原来的基础上增加1。<br>这就是闭包的作用，有时候我们需要一个模块中定义这样一个变量：希望这个变量一直保存在内存中，但又不会“污染”全局的变量，这个时候，我们就可以用闭包来定义这个模块。</p>
<h3 id="结语">结语</h3><p>上面的例子只是最简陋的写法，实际中不会这么写。这里只是为了加深理解。当然，如果要全面理解闭包，仅凭上面的文字和代码是远远不够的。在项目中不妨试着使用闭包，用的多了自然会有独到的理解。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2016/03/23/JavaScript学习笔记-2/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="Ji Xiang">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="http://o7bp9e1ec.bkt.clouddn.com/1485173143816">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="Ji Xiang's blog">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="Ji Xiang's blog" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/03/23/JavaScript学习笔记-2/" itemprop="url">
                  JavaScript学习笔记(2)
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-03-23T16:08:12+08:00">
                2016-03-23
              </time>
            

            

            
          </span>

          

          
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="JavaScript内存管理">JavaScript内存管理</h2><h3 id="1-简介">1.简介</h3><p>低级语言，比如C，有低级的内存管理基元，像malloc(),free()。另一方面，JavaScript的内存基元在变量（对象，字符串等等）创建时分配，然后在他们不再被使用时“自动”释放。后者被称为垃圾回收。这个“自动”是产生混淆的源头，并给JavaScript（和其他高级语言）开发者一个印象：他们可以不用考虑内存管理。这是错误的。   </p>
<h3 id="2-内存生命周期">2.内存生命周期</h3><p>不管什么程序语言，内存生命周期基本一致：<br>分配你所需要的内存   </p>
<ol>
<li>使用它（读、写）   </li>
<li>当它不被使用时释放   </li>
<li>当它不被使用时释放<br>第一二部分过程在所有语言中都很清晰。最后一步在低级语言中很清晰，但是在像JavaScript等高级语言中，最后一步不清晰。    </li>
</ol>
<h3 id="3-JavaScript的内存分配">3.JavaScript的内存分配</h3><h3 id="3-1_值的初始化">3.1 值的初始化</h3><p>为了不让程序员费心分配内存，JavaScript在定义变量时完成内存分配。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> n = <span class="number">123</span>; <span class="comment">// 给数值变量分配内存</span></span><br><span class="line"><span class="keyword">var</span> s = <span class="string">"azerty"</span>; <span class="comment">// 给字符型</span></span><br><span class="line"><span class="keyword">var</span> o = &#123;</span><br><span class="line">  a: <span class="number">1</span>,</span><br><span class="line">  b: <span class="literal">null</span></span><br><span class="line">&#125;; <span class="comment">// 为对象及其包含变量分配内存</span></span><br><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>, <span class="literal">null</span>, <span class="string">"abra"</span>]; <span class="comment">// 为数组及其包含变量分配内存（就像对象一样）</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">a</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a + <span class="number">2</span>;</span><br><span class="line">&#125; <span class="comment">// 为函数（可调用的对象）分配内存</span></span><br><span class="line"><span class="comment">// 函数表达式也能分配一个对象</span></span><br><span class="line">someElement.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  someElement.style.backgroundColor = <span class="string">'blue'</span>;</span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure></p>
<h3 id="3-2_通过函数调用的内存分配">3.2 通过函数调用的内存分配</h3><p>有些函数调用结果是分配对象内存：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> d = <span class="keyword">new</span> <span class="built_in">Date</span>(); <span class="comment">//分配一个Date对象</span></span><br><span class="line"><span class="keyword">var</span> e = <span class="built_in">document</span>.createElement(<span class="string">'div'</span>); <span class="comment">//分配一个DOM元素</span></span><br></pre></td></tr></table></figure></p>
<p>有些方法分配新变量或者新对象：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="string">"azerty"</span>;</span><br><span class="line"><span class="keyword">var</span> s2 = s.substr(<span class="number">0</span>, <span class="number">3</span>); <span class="comment">// s2是一个新字符串</span></span><br><span class="line"><span class="comment">//因为字符串是不变量，JavaScript可能没有分配内存，但只是存储了0-3的范围。</span></span><br><span class="line"><span class="keyword">var</span> a = [<span class="string">"ouais ouais"</span>, <span class="string">"nan nan"</span>];</span><br><span class="line"><span class="keyword">var</span> a2 = [<span class="string">"generation"</span>, <span class="string">"nan nan"</span>];</span><br><span class="line"><span class="keyword">var</span> a3 = a.concat(a2); <span class="comment">// 新数组中有连接数组a和数组a2中的四个元素。</span></span><br></pre></td></tr></table></figure></p>
<h3 id="3-3_值的使用">3.3 值的使用</h3><p>使用值的过程实际上是对分配内存进行读取与写入的操作。读取与写入可能是写入一个变量或者一个对象的属性值，甚至传递函数的参数。   </p>
<h3 id="3-4_当内存不再需要使用时释放">3.4 当内存不再需要使用时释放</h3><p>大多数内存管理的问题都在这个阶段。在这里最艰难的任务是找到“所分配的内存确实已经不再需要了”。它往往要求开发人员来确定在程序中哪一块内存不再需要并且释放它。<br>高级语言解释器嵌入了“垃圾回收器”，它的主要工作是跟踪内存的分配和使用，以便当分配的内存不再使用时，自动释放它。这只能是一个近似的过程，因为要知道是否仍然需要某块内存是无法判定的(无法通过某种算法解决).</p>
<h2 id="4-_垃圾回收"><b>4. 垃圾回收</b></h2><p>如上文所述自动寻找是否一些内存“不再需要”的问题是无法判定的。因此，垃圾回收实现只能有限制的解决一般问题。本节将解释必要的概念，了解主要的垃圾回收算法和它们的局限性。</p>
<h3 id="4-1_引用">4.1 引用</h3><p>垃圾回收算法主要依赖于引用的概念。在内存管理的环境中，一个对象如果有访问另一个对象的权限（隐式或者显式），叫做一个对象引用另一个对象。例如，一个Javascript对象具有对它 原型 的引用（隐式引用）和对它属性的引用（显式引用）。<br>在这里，“对象”的概念不仅特指Javascript对象，还包括函数作用域（或者全局词法作用域）。</p>
<h3 id="4-2_引用计数垃圾收集">4.2 引用计数垃圾收集</h3><p>这是最简单的垃圾收集算法。此算法把“对象是否不再需要”简化定义为“对象有没有其他对象引用到它”。如果没有引用指向该对象（零引用），对象将被垃圾回收机制回收。<br>例如：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123;</span><br><span class="line">  a: &#123;</span><br><span class="line">    b:<span class="number">2</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 两个对象被创建，一个作为另一个的属性被引用，另一个被分配给变量o</span></span><br><span class="line"><span class="comment">// 很显然，没有一个可以被垃圾收集</span></span><br><span class="line"><span class="keyword">var</span> o2 = o; <span class="comment">// o2变量是第二个对“这个对象”的引用</span></span><br><span class="line">o = <span class="number">1</span>; <span class="comment">// 现在，“这个对象”的原始引用o被o2替换了</span></span><br><span class="line"><span class="keyword">var</span> oa = o2.a; <span class="comment">// 引用“这个对象”的a属性</span></span><br><span class="line"><span class="comment">// 现在，“这个对象”有两个引用了，一个是o2，一个是oa</span></span><br><span class="line">o2 = <span class="string">"yo"</span>; <span class="comment">// 最初的对象现在已经是零引用了</span></span><br><span class="line"><span class="comment">// 他可以被垃圾回收了</span></span><br><span class="line"><span class="comment">// 然而它的属性a的对象还在被oa引用，所以还不能回收</span></span><br><span class="line">oa = <span class="literal">null</span>; <span class="comment">// a属性的那个对象现在也是零引用了</span></span><br><span class="line"><span class="comment">// 它可以被垃圾回收了</span></span><br></pre></td></tr></table></figure></p>
<p><b>限制：循环引用</b></p>
<p>这个简单的算法有一个限制，就是如果一个对象引用另一个（形成了循环引用），他们可能“不再需要”了，但是他们不会被回收。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> o = &#123;&#125;;</span><br><span class="line">  <span class="keyword">var</span> o2 = &#123;&#125;;</span><br><span class="line">  o.a = o2; <span class="comment">// o 引用 o2</span></span><br><span class="line">  o2.a = o; <span class="comment">// o2 引用 o</span></span><br><span class="line">  <span class="keyword">return</span> <span class="string">"azerty"</span>;</span><br><span class="line">&#125;</span><br><span class="line">f();</span><br><span class="line"><span class="comment">// 两个对象被创建，并互相引用，形成了一个循环</span></span><br><span class="line"><span class="comment">// 他们被调用之后不会离开函数作用域</span></span><br><span class="line"><span class="comment">// 所以他们已经没有用了，可以被回收了</span></span><br><span class="line"><span class="comment">// 然而，引用计数算法考虑到他们互相都有至少一次引用，所以他们不会被回收</span></span><br></pre></td></tr></table></figure></p>
<p><b>实际当中的例子</b><br>IE 6, 7 对DOM对象进行引用计数回收。对他们来说，一个常见问题就是内存泄露：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> div = <span class="built_in">document</span>.createElement(<span class="string">"div"</span>);</span><br><span class="line">div.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  doSomething();</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// div有了一个引用指向事件处理属性onclick</span></span><br><span class="line"><span class="comment">// 事件处理也有一个对div的引用可以在函数作用域中被访问到</span></span><br><span class="line"><span class="comment">// 这个循环引用会导致两个对象都不会被垃圾回收</span></span><br></pre></td></tr></table></figure></p>
<h3 id="4-3_标记-清除算法">4.3 标记-清除算法</h3><p>这个算法把“对象是否不再需要”简化定义为“对象是否可以获得”。</p>
<p>这个算法假定设置一个叫做根的对象（在Javascript里，根是全局对象）。定期的，垃圾回收器将从根开始，找所有从根开始引用的对象，然后找这些对象引用的对象……从根开始，垃圾回收器将找到所有可以获得的对象和所有不能获得的对象。</p>
<p>这个算法比前一个要好，因为“有零引用的对象”总是不可获得的，但是相反却不一定，参考“循环引用”。</p>
<p>从2012年起，所有现代浏览器都使用了标记-清除垃圾回收算法。所有对JavaScript垃圾回收算法的改进都是基于标记-清除算法的改进，并没有改进标记-清除算法本身和它对“对象是否不再需要”的简化定义。</p>
<p><b>循环引用不再是问题了</b></p>
<p>在上面的示例中，函数调用返回之后，两个对象从全局对象出发无法获取。因此，他们将会被垃圾回收器回收。<br>第二个示例同样，一旦 div 和其事件处理无法从根获取到，他们将会被垃圾回收器回收<br>。</p>
<p><b>限制: 那些无法从根对象查询到的对象都将被清除</b></p>
<p>尽管这是一个限制，但实践中我们很少会碰到类似的情况，所以开发者不太会去关心垃圾回收机制。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2016/03/19/JavaScript学习笔记-1/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="Ji Xiang">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="http://o7bp9e1ec.bkt.clouddn.com/1485173143816">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="Ji Xiang's blog">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="Ji Xiang's blog" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/03/19/JavaScript学习笔记-1/" itemprop="url">
                  JavaScript学习笔记(1)
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-03-19T14:30:51+08:00">
                2016-03-19
              </time>
            

            

            
          </span>

          

          
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="JavaScript中的apply(),_call()和arguments对象">JavaScript中的apply(), call()和arguments对象</h2><blockquote>
<p>学习JavaScript，应该掌握函数式编程的特点和方法，为了做到这一点，详细理解函数调用和函数原型是非常有必要的。<br>打开浏览器，按F12打开浏览器控制台，选择console，让我们在console控制台里编写一些javascript代码来深入了解关于函数的一些知识。</p>
</blockquote>
<h3 id="函数原型">函数原型</h3><p>输入：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.getOwnPropertyNames(<span class="built_in">Function</span>.prototype);</span><br></pre></td></tr></table></figure>
<p>得到：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">"length"</span>, <span class="string">"name"</span>, <span class="string">"arguments"</span>, <span class="string">"caller"</span>, <span class="string">"apply"</span>, <span class="string">"bind"</span>, <span class="string">"call"</span>, <span class="string">"toString"</span>, <span class="string">"constructor"</span>]</span><br></pre></td></tr></table></figure></p>
<p>这里的输出依赖于你使用的浏览器和JavaScript版本。以上属性里，我们将讨论以下这几个：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.length</span><br><span class="line"><span class="built_in">Function</span>.prototype.call</span><br><span class="line"><span class="built_in">Function</span>.prototype.apply</span><br></pre></td></tr></table></figure></p>
<p>首先，我们定义一个 “test” 函数：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> test = <span class="function"><span class="keyword">function</span> (<span class="params">a, b, c</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(&#123;<span class="keyword">this</span>: <span class="keyword">this</span>, a: a, b: b, c: c&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个函数简单记录了上下文变量(context)，即this的值，和输入参数的值。然后，我们输入不同的参数来调用这个函数：   </p>
<p>test(‘a’);<br>得到：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span> &#123; <span class="keyword">this</span>: Window, a: <span class="string">"a"</span>, b: <span class="literal">undefined</span>, c: <span class="literal">undefined</span> &#125;</span><br></pre></td></tr></table></figure>
<p>test(‘this’, ‘is’, ‘cool’);<br>得到：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span> &#123; <span class="keyword">this</span>: Window, a: <span class="string">"this"</span>, b: <span class="string">"is"</span>, c: <span class="string">"cool"</span> &#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>我们注意到，如果我们不输入第2、3个参数，浏览器将显示undefined。此外，我们注意到这个函数默认的上下文是全局对象Window。</p>
</blockquote>
<h3 id="使用Function-prototype-call">使用Function.prototype.call</h3><p>调用call函数时，需要把上下文变量this作为第一个输入的参数，然后传进其他参数。<br><em>syntax:</em><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>.<span class="title">call</span>(<span class="params">this, arg1, arg2, ..., argn</span>);</span></span><br></pre></td></tr></table></figure></p>
<p>因此，下面这两行是等效的：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">test(<span class="string">'this'</span>, <span class="string">'is'</span>, <span class="string">'cool'</span>);   </span><br><span class="line">test.call(Window, <span class="string">'this'</span>, <span class="string">'is'</span>, <span class="string">'cool'</span>);</span><br></pre></td></tr></table></figure>
<h3 id="使用Function-prototype-apply">使用Function.prototype.apply</h3><p>函数apply比call更实用一些，和call类似，apply的调用方式也是把变量this设置为输入参数序列中的第一个参数的值，但输入参数序列的第二个参数也是最后一个，以数组（或者数组对象）的方式传入。<br><em>Syntax:</em></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>.<span class="title">apply</span>(<span class="params">this, [arg1, arg2, ..., argn]</span>);</span></span><br></pre></td></tr></table></figure>
<p>因此，下面三行全部等效:   </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tester(<span class="string">"this"</span>, <span class="string">"is"</span>, <span class="string">"cool"</span>);   </span><br><span class="line">tester.call(<span class="built_in">window</span>, <span class="string">"this"</span>, <span class="string">"is"</span>, <span class="string">"cool"</span>);   </span><br><span class="line">tester.apply(<span class="built_in">window</span>, [<span class="string">"this"</span>, <span class="string">"is"</span>, <span class="string">"cool"</span>]);</span><br></pre></td></tr></table></figure>
<p>能够以数组的方式指定一个参数列表在多数时候非常有用（我们会发现这样做的好处的）。例如，Math.max是一个可变参数函数（一个函数可以接受任意数目的参数）。  </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Math</span>.max(<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>); <span class="comment">//=&gt; 3   </span></span><br><span class="line"><span class="built_in">Math</span>.max(<span class="number">2</span>,<span class="number">1</span>); <span class="comment">//=&gt; 2</span></span><br></pre></td></tr></table></figure>
<p>这样，如果我有一个数值数组，并且我需要利用Math.max函数找出其中最大的那个，我怎么用一行代码来做这个事儿呢？   </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> numbers = [<span class="number">3</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">3</span>, <span class="number">1</span>];   </span><br><span class="line"><span class="built_in">Math</span>.max.apply(<span class="literal">null</span>, numbers);   </span><br><span class="line"><span class="comment">//=&gt; 8</span></span><br></pre></td></tr></table></figure>
<h3 id="apply方法真正开始显示出它的重要是当配上特殊参数：Arguments对象。">apply方法真正开始显示出它的重要是当配上特殊参数：Arguments对象。</h3><p>每个函数表达式在它的作用域中都有一个特殊的、可使用的局部变量：arguments。为了研究它的属性，让我们创建另一个test函数:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> tester = <span class="function"><span class="keyword">function</span>(<span class="params">a, b, c</span>) </span>&#123;   </span><br><span class="line">	<span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertyNames(<span class="built_in">arguments</span>));   </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注：在这种情况下我们必须像上面这样使用Object.getOwnPropertyNames，因为arguments有一些属性没有标记为可以被枚举的，于是如果仅仅使用console.log(arguments)这种方式它们将不会被显示出来。   </p>
</blockquote>
<p>现在我们按照老办法，通过调用test函数来测试下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">test(<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>);</span><br><span class="line"><span class="comment">//=&gt; ["0", "1", "2", "length", "callee"]</span></span><br><span class="line"></span><br><span class="line">test.apply(<span class="literal">null</span>, [<span class="string">"a"</span>]);</span><br><span class="line"><span class="comment">//=&gt; ["0", "length", "callee"]</span></span><br></pre></td></tr></table></figure>
<p>arguments变量的属性中包括了对应于传入函数的每个参数的属性，这些和.length属性、.callee属性没什么不同。<br>.callee属性提供了调用当前函数的函数的引用，但是这并不被所有的浏览器支持。就目前而言，我们忽略这个属性。<br>让我们重新定义一下我们的test函数，让它丰富一点：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> tester = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(&#123;</span><br><span class="line">		<span class="string">'this'</span>: <span class="keyword">this</span>,</span><br><span class="line">		<span class="string">'arguments'</span>: <span class="built_in">arguments</span>,</span><br><span class="line">		<span class="string">'length'</span>: <span class="built_in">arguments</span>.length</span><br><span class="line">	&#125;);</span><br><span class="line">&#125;;</span><br><span class="line">tester.apply(<span class="literal">null</span>, [<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>]);</span><br><span class="line"><span class="comment">//=&gt; &#123; this: null, arguments: &#123; 0: "a", 1: "b", 2: "c" &#125;, length: 3 &#125;</span></span><br></pre></td></tr></table></figure>
<p>Arguments:是对象还是数组？<br>我们看得出，arguments完全不是一个数组，虽然多多少少有点像。在很多情况下，尽管不是，我们还是希望把它当作数组来处理。把arguments转换成一个数组，这有个非常不错的快捷小函数：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">toArray</span>(<span class="params">args</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Array</span>.prototype.slice.call(args);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> example = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">arguments</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(toArray(<span class="built_in">arguments</span>));</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">example(<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>);</span><br><span class="line"><span class="comment">//=&gt; &#123; 0: "a", 1: "b", 2: "c" &#125;</span></span><br><span class="line">	<span class="comment">//=&gt; ["a", "b", "c"]</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>这里我们利用Array.prototype.slice方法把类数组对象转换成数组。因为这个，在与.apply同时使用的时候arguments对象最终会极其有用。</p>
</blockquote>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>


          
          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="http://o7bp9e1ec.bkt.clouddn.com/1485173143816"
               alt="Ji Xiang" />
          <p class="site-author-name" itemprop="name">Ji Xiang</p>
          <p class="site-description motion-element" itemprop="description"></p>
        </div>
        <nav class="site-state motion-element">
        
          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">14</span>
                <span class="site-state-item-name">posts</span>
              </a>
            </div>
          

          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">9</span>
                <span class="site-state-item-name">tags</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Ji Xiang</span>
</div>


<div class="powered-by">
  Powered by <a class="theme-link" href="https://hexo.io">Hexo</a>
</div>

<div class="theme-info">
  Theme -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>


        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  




  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  



  




	





  





  

  




  
  

  

  

  

  


</body>
</html>
